($wrapapplicatives)
($define $umacro
  ($uvau (name args body)
    (~ $define name (~ $uvau args body name)) $umacro))

($define $macro
  ($uvau (name args body)
    (~ $define name (~ $vau args body name)) $macro))

($macro $lambda (args body name)
  (wrap (~ $uvau args body) name))

($umacro $function (name args body)
  (~ $define name (~ $lambda args body name)))

($umacro $comp (name args body)
  (~ $define (~ $symextend name "comp") (~ $vau args body)))

($macro $cadr (l) ($car ($cdr l)))

($function cadr (l) (car (cdr l)))

($macro $let (defs body)
  (eval (cons (~ $lambda (mapcar defs $car) body 'letbody) (mapcar defs $cadr))))

($macro $when (
    cond ;; whether
    body ;; to do
    (doc "when this, do that")
  )
  ($if (eval cond)
    (eval body)
    false))

($macro $cond ((rest ifthens))
  ($let
    ((head (car ifthens))
     (tail (cdr ifthens)))
    ($if (eval (car head))
      (cadr head)
      ($when (is tail)
        (apply $cond tail)))))

($function fact (n)
  ($if (eq n 0)
    1
    (* n (fact (- n 1)))))

($function pow (n p)
  ($if (eq p 0)
    1
    (* n (pow n (- p 1)))))

;; the slow way!
(debug "vaucomp")

($function fib (n)
  ($if (lt n 2)
    n
    (+ (fib (- n 1)) (fib (- n 2)))))
(cleardebug)

($logtime (nativefib 24))

($logtime (fib 24))

($function fibfact (n)
  ($let
    ((fibn (fib n))
     (factn (fact n)))
    (* fibn factn)))
(log (fibfact 10))

(log (concat "cond "
  ($cond
    ((gt (fib 5) 150) "bad")
    ((lt (fib 5) 150) "good")
    (true "bad again"))))
(log (run "(+ (fact 5) 7)"))
(log (jsrun "let n = 1; for (let i = 0; i < 10; i++) { n = (n + i) * 2; } return n"))
