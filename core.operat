($define $umacro
  ($uvau (name args body)
    (~ $define name (~ $uvau args body name)) $umacro))

($define $macro
  ($uvau (name args body)
    (~ $define name (~ $vau args body name)) $macro))

($macro $lambda (args body name)
  (wrap (~ $uvau args body) name))

(log (($lambda (n) (* n 2)) 4))

($umacro $function (name args body)
  (~ $define name (~ $lambda args body name)))

($macro $comp (name args body)
  (list 'set name 'comp (~ $lambda args body)))

;($comp * (a b)
;  (concat (~ $compile a) " * " (~ $compile b)))

;(log (get '* 'comp))

($macro $cadr (l) ($car ($cdr l)))

($function cadr (l) (car (cdr l)))

($function lettest (c)
  ($let ((a 3) (b ($dbg + 2 c))) (* a b)))

(log "lettest" (lettest 5))

($macro $when (
    cond ;; whether
    body ;; to do
    (doc "when this, do that")
  )
  ($if (eval cond)
    (eval body)
    false))

($macro $cond ((rest ifthens))
  ($let
    ((head (car ifthens))
     (tail (cdr ifthens)))
    ($if (eval (car head))
      (eval (cadr head))
      ($if (is tail)
        (apply $cond tail)
        false))))

($function fact (n)
  ($if (eq n 0)
    1
    (* n (fact (- n 1)))))

($function pow (n p)
  ($if (eq p 0)
    1
    (* n (pow n (- p 1)))))

;; the slow way!
($function fib (n)
  ($if (lt n 2)
    n
    (+ (fib (- n 1)) (fib (- n 2)))))

($logtime (_nativefib 24))

($logtime (fib 24))

(log (concat "cond "
  ($cond
    ((gt (fib 5) 150) "bad")
    ((lt (fib 5) 150) "good")
    (true "bad again"))))

($function fibfact (n)
  ($let
    ((fibn (fib n))
    (factn (fact n)))
    (* fibn factn)))
(log (fibfact 10))

(log (run "(+ (fact 5) 7)"))
(log (jsrun "let n = 1; for (let i = 0; i < 10; i++) { n = (n + i) * 2; } return n"))

($defclass point ()
  (parameter x (type number) (default 0))
  (parameter y (type number) (default 0))
  (method translate
    (args (
      (arg dx (type number) (default 0))
      (arg dy (type number) (default 0))
    ))
    (returns self)
    (fn (
      ($SET X (+ X DX))
      ($SET Y (+ Y DY))
    ))
  )
)

($defclass point () {
  x: (parameter {
    type: number
    default: 0
  })
  y: (parameter {
    type: number
    default: 0
  })
  translate: (method {
    args: ({ name: dx type: number default 0 } { name: dy type: number default 0 })
    returns: self
    fn: (($>> x (+ x dx)) ($>> y (+ y dy)))
  })
})

($defclass shape ()
  (function area
    (args ())
    (returns number)
    virtual
  )
)

($defclass circle (shape point)
  (parameter r (type number) (default 1))
  (function area (fn (* PI (pow r 2))))
  )

($let ((c ($make circle (r 5))))
  (log (c area)))
